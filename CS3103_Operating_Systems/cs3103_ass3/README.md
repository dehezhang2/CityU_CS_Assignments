# Assignment 3: A Simulator for FIFO Queue with Progressive Flow

This assignment implements a simulator for FIFO Queue with progressive flow

The way to compile the program and some details about the program:

1. I have submitted 3 versions of `PFIFO` in this assignment, here is difference of them

    * The first version `boolean.cpp` use a semaphore and a boolean variable to achieve the synchronization:  In this version, server will not blocked after the activating the pflow thread, 
      i.e. although it cannot activate it twice after empty the queue, it can still continue to run the code of the server. The semaphore empty is set to be zero at first, pflow will block on it, the boolean  variable `pflow_running `is set to be false at first. When the server empty the queue, and current sequence number is not zero and boolean value is false, it will post the semaphore empty and set `pflow_running` to be true. As long as the `pflow` thread is stopped, it will set the boolean value to be false. The semaphore empty is protected by the boolean value, because the server will post
      empty only when the boolean value is false, and the boolean value is set to be false only when the pflow is finished
    * The second version `two_semaphore.cpp` use two semaphores to achieve the synchronization: In this version, server will be blocked immediately after activating the `pflow`, and activated by the pflow after pflow finishing the refilling. The semaphore empty and server_permission is set to be zero at first. when the server empty the queue, it will post the semaphore empty and release the mutex. After than, it will blocked on the semaphore server_permission whose value is set to be zero first. Once the pflow finished, it will activate the server.

    * The third version ` multiserver.cpp` use two semaphores to achieve the synchronization: If we consider the case that there are multiple server(although in this assignment, there is only one), 
      if we need to block all the server before the pflow is finished. We need to use the same trick in the
      vendor&seller problem taught in the tutorial. Now the semaphore empty is also set to be zero at first, but the semaphore server_permission is set to be one, and a boolean value refilling is set to be false at first. The implementation is very similar to the vendor problem. 

2. About the pflow problem mentioned in the remark 1:

    I have several lines of codes to solve this problem, if you want to see the result of these lines of code, 
    please compile the program by 

    ```bash
    g++ 55199998_ONE_OF_THE_VERSIONS.cpp -o PFIFO -lpthread -D AVOID
    ```


3. The queue structure is defined in the header file "Queue.h". 

4. To compile the program, use the following command line is enough (PFIFO can be changed to any name you like)

    ```bash
    g++ 55199998.cpp -o PFIFO -lpthread
    ```

## All possible Outputs of the Program

1. If the user call the executable file with more or less than 2 variables, the program will output and terminate:

        Usage: $ ./Filename max_token flow_interval(only accept 2 variables)

2. If the input variables are not numbers or zero, the program will output and terminate:

        Input error!

3. If the variables are correctly inputted, the main thread will print the header of the table
   
        Flow         Queue                                  Server
        Token added  Latest sequence number Current Length  Token served Total Token fetched


4. If there is something wrong when creating/joining thread or locking/unlocking the mutex, the program will output and terminate:
   
        Error when creating/joining the thread, error number: x
        Error when locking/unlocking the mutex, error number: x
   
   where x is the error number!

5. If there is something wrong when initializing, waiting, posting or destroying the semaphore, the program will output and terminate:

        Error when initializing/waiting/posting/destroying the semaphore!

6. If the 2 threads are started successfully, they will do the simulation and print

        aaa(flow/pflow)          bbb                    ccc            
                                                        zzz             xxx          yyy

   where `aaa` is random number generated by flow or pflow, `bbb` is the last sequence number, `ccc` and `zzz` is the current queue length,`xxx` is the token fetched in the current round, `yyy` is the total token fetched
   
7. When the addition of dropped token and fetched token is larger than max token, the simulation will be terminated and output

        The total number of tokens that have been fetched by the server is eee.
        The total number of tokens that have been generated by the flow is fff.
        The total number of tokens that have been generated by the pflow is ggg.
        The total number of tokens that have been dropped by the queue is hhh.
